{
  "publishedAt": "02-26-2022",
  "content": "In this part we will be discussing the OrderCloud Catalyst library. This Catalyst library can be very helpful when creating a middleware application which acts as the gateway between your frontend application (like a shop) and OrderCloud itself.\n\nIn this blog post I will be sharing some of the things I learned about the OrderCloud Catalyst library. This is, next to the .NET SDK which I explained in my previous post, another .NET based NuGet library going by the name of \"ordercloud-dotnet-catalyst\".\\\nThe Catalyst library comes with a set of features helping you to build functionalities in your application. This library is especially useful when building a middleware type of application.\\\nThese features or helpers include things like:\n\n* Authentication and Authorization helpers\n* Result listing helpers\n* Caching\n* Throttling requests\n* Error Handling\n\nIn this post I won't be showing all those features as I have not tried all of them yet. Instead, we will be focusing on the two, in my opinion, most important features, Authorization and Caching. \n\n## Authorization\n\nOrderCloud especially excels in the flexibility you have around creating organizational structures of users and their roles. By default, the product knows quite some roles which you can assign to any user, but you also don't want any unwanted API calls being made by users who should not have access to certain functionalities.\\\nTo make it easier for us to manage security checks, Catalyst provides some Authentication and Authorization helpers which we can use in our MVC based APIs.\n\nYou can make use of these helpers as part of your MVC Controller. For this to work, your Controller needs to be based on the OrderCloud.Catalyst.CatalystController.\\\nWhen a request is made to a CatalystController, the provided Bearer token is decoded and stored as a variable on the Controller.\n\n```csharp\npublic override void OnActionExecuting(ActionExecutingContext context)\n{\n    string text = base.User.Claims.FirstOrDefault((Claim claim) => claim.Type == \"AccessToken\")?.Value;\n    if (text != null)\n    {\n        UserContext = new DecodedToken(text);\n    }\n  \n    base.OnActionExecuting(context);\n}\n```\n\nThis DecodedToken object stored as UserContext contains some helpful properties about the user making the request, like:\n\n* AccessToken; This token can be used in the API calls to OrderCloud through the SDK to impersonate this user.\n* Username\n* Roles\n\nOnce you have the Controller, you can create methods for your API. Those methods can be annotated using attributes. You can use the Microsoft.AspNetCore.Authorization.AuthorizeAttribute attribute for example to specify any authorization rules for the given request.\\\nOrderCloud has extended this attribute, as OrderCloud.Catalyst.OrderCloudUserAuth, so that you can specify which OrderCloud roles have access to this request. The roles of the context user making the request (UserContext.Roles) are then validated against the list of roles specified in this attribute.\n\n```csharp\n[HttpGet(Name = \"GetAllCatalogs\"), OrderCloudUserAuth(ApiRole.Shopper)]\npublic async Task<IActionResult> Get()\n{\n    var result = await _catalogService.GetAllCatalogs(UserContext.AccessToken);\n    return !result.Ok ? Api.BadRequest(result) : Api.Ok(result);\n}\n```\n\nThis way your application will do the validation before making any subsequent request to OrderCloud instead of OrderCloud returning an error. But you can also just use it for any custom-built functionalities which don't use OrderCloud at all.\n\nWhen you are building APIs which function as a proxy to OrderCloud rather than offering custom built functionalities, you will probably want to specify this OrderCloudUserAuth attribute using the roles which we know have access to the OrderCloud API. You can find these roles in the API reference documentation on ordercloud.io where each request shows which roles have access to that API. <https://ordercloud.io/api-reference>\n\n## Caching\n\nThe second functionality I want to cover is caching. Catalyst offers a very simple caching mechanism which by default is setup using LazyCache, which is a 3rd party library requiring no configuration but is only caching locally using memory.\n\nTo use this caching mechanism, we can use the ISimpleCache service. This service only has two methods and by default is implemented using LazyCache.\n\n```csharp\npublic interface ISimpleCache\n{\n    /// <summary>\n    /// Get the value directly from the cache if it exists. If not, call addItemFactory() and cache the result for future use.\n    /// </summary>\n    /// <param name=\"key\">Unique key pointing to a value in the cache</param>\n    /// <param name=\"expireAfter\">Time before the cache is cleared. Also called \"Time to Live\"</param>\n    /// <param name=\"addItemFactory\">A function to calculate the value fully.</param>\n    /// <returns></returns>\n    Task<T> GetOrAddAsync<T>(string key, TimeSpan expireAfter, Func<Task<T>> addItemFactory);\n    /// <summary>\n    /// Remove the value from the cache.\n    /// </summary>\n    /// <param name=\"key\">Unique key pointing to a value in the cache</param>\n    Task RemoveAsync(string key);\n}\n```\n\nTo use a different caching implementation, we could overwrite the service registration with our own implementation for ISimpleCache.\n\n```csharp\npublic static void AddCustomCache(this IServiceCollection services) {\n  services.AddSingleton<ISimpleCache, MyCacheService>();\n}\n```\n\nThis caching functionality might not seem like a lot, but a good reason to use it is because Catalyst uses this feature itself.\\\nThe OrderCloudUserAuth attribute, as mentioned earlier, uses this ISimpleCache service to cache the token validation requests it makes to OrderCloud APIs. This way, when a user performs multiple actions in a short period of time, the token is only verified once every hour instead of it having to be verified on each request.\n\nOverall, the Catalyst library seems like a very neat set of functionalities which you could use in any Middleware implementation around OrderCloud. It is both easy to setup as well as use.\\\nIn a next post I will be sharing some insights about the OrderCloud Headstart demo application as well as my unsalted thoughts about it.",
  "seoDescription": "Taking a first look at the OrderCloud Catalyst library and figuring out how it helps us with Authentication and Caching.",
  "title": "A first look at the OrderCloud Catalyst library"
}