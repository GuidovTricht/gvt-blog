{
  "publishedAt": "06-16-2023",
  "title": "Automated Sitecore content synchronization using Item as Resources",
  "content": "Synchronizing content between Sitecore environments, especially copying production content to non-production environments, has always been challenging. The introductions of serialization tools, such as Unicorn, made it a little easier. With Sitecore 10, Sitecore release d their very own Sitecore CLI, capable of pulling and pushing content from new APIs available in the CMS.\n\nAdditionally, Sitecore 10 came with a feature called “Items as Resources” (read more in Sitecore’s [documentation](https://doc.sitecore.com/xp/en/developers/103/developer-tools/items-as-resources-plugin.html)). With this feature, you can create a .dat file which is read during the startup of Sitecore and inserts items stored in that file in the content tree, removing the requirement to always store all items in the Sitecore databases.\n\nThis feature comes with a plugin for Sitecore’s CLI. Using the commands in this plugin, you can create resource files based on your Sitecore Content Serialization (SCS) configuration and serialized items.\n\nTo create a resource file based on your SCS serialized items, you need to run the following command in PowerShell.\n\n```powershell\ndotnet sitecore itemres create -o [file name]\n```\n\nThis command will create a resource file based on all the SCS modules you have created. The serialized items you have on disk for those modules will be added to the file, and when deployed to Sitecore they will show up in the content tree.\n\nThe *itemres* command has two helpful options to limit the included SCS modules. Just like the *ser* command, it has the *\\--include* and *\\--exclude* options to either include or exclude SCS modules based on their name.\n\nThe following example shows how this can be used to exclude any modules in the Project layer:\n\n```powershell\ndotnet sitecore itemres create -o [file name] -e Project.*\n```\n\nThe file that is created will have to be deployed to both your CM and CD instances. By copying them to the ~/App_Data/items/ folder of you Sitecore instance, they will be read during the Sitecore startup process and included in the content editor.\n\n## Creating a resource file in your deployment process\n\nWe have now seen how you can use the itemres commands to create a  resources file from your local repository, but when doing this for a content synchronization process there are some preliminary steps that need to be taken.\n\nFor a process to synchronize production content down to lower environments, you will want to create one or more SCS modules specific to the content that you want to synchronize.\n\nLet’s take this SCS module as an example\n\n```json\n{\n  \"namespace\": \"Content.Corporate\",\n  \"description\": \"Corporate Content\",\n  \"items\": {\n    \"includes\": [\n      {\n        \"database\": \"web\",\n        \"name\": \"Corporate\",\n        \"path\": \"/sitecore/content\"\n      },\n      {\n        \"database\": \"web\",\n        \"name\": \"Forms\",\n        \"path\": \"/sitecore/Forms\"\n      }\n    ]\n  }\n}\n```\n\nNote that in this example we configure the module to pull content from the web database and not master. This can be useful if you only want to synchronize content that has been published.\n\nIn order to create a  resources file for this content in your deployment process, you will need to first pull this content from the environment you want to use as a source of your synchronization. This means you first need to login to the Sitecore environment using the Sitecore CLI, before being able to pull content.\n\nBefore you can run Sitecore CLI commands, you need to make sure the Azure DevOps build agent has all the tools required. The first steps we run as part of this synchronization pipeline will be to do a checkout of the repository, installing the right version of .NET for the CLI to run, and restoring the dotnet tools.\n\nThe following pipeline yaml snippet shows how you can run these tasks.\n\n```yaml\njobs:\n- job: create_itemres_files\n  displayName: 'Create Items as Resources files'\n  steps:\n  - checkout: self\n\n  - task: UseDotNet@2\n    displayName: Install .NET 6.x\n    inputs:\n      packageType: 'sdk'\n      version: '6.x'\n\n  - task: DotNetCoreCLI@2\n    displayName: Dotnet Tool Restore\n    inputs:\n      command: 'custom'\n      custom: 'tool'\n      arguments: 'restore'\n```\n\nAfter executing these tasks, the build agent is ready to run Sitecore CLI commands. The next step is to login to Sitecore. For this, we need to make use of the feature to specify a client ID and secret during the login command.\n\n```yaml\n  - task: DotNetCoreCLI@2\n    displayName: Login to Sitecore CLI\n    inputs:\n      command: 'custom'\n      custom: 'sitecore'\n      arguments: 'login --cm ${{ parameters.sitecore_cm_url }} --auth ${{ parameters.sitecore_auth_url }} --allow-write true --client-credentials true --client-id CLI --client-secret ${{ parameters.sitecore_cli_secret }}'\n```\n\nNow that the build agent CLI is logged in to Sitecore, we can run the serialization pull command to pull the content from the Sitecore environment.\n\n```yaml\n  - task: DotNetCoreCLI@2\n    displayName: Sitecore ser pull\n    inputs:\n      command: 'custom'\n      custom: 'sitecore'\n      arguments: 'ser pull -i Content.Corporate\n```\n\nThis will create the serialized items on disk needed as a basis for our resources file. Again, note that you only want to include the SCS modules that should end up in the resources file, in this case the Content.Corporate module only.\n\n```yaml\n  - task: DotNetCoreCLI@2\n    displayName: Sitecore itemres create\n    inputs:\n      command: 'custom'\n      custom: 'sitecore'\n      arguments: 'itemres create -o content -i Content.Corporate'\n```\n\nAfter running these commands, you will have created a resources file (following the examples it will be named content.dat) which can be copied to your Sitecore environment.\nIf your next step is to build a Docker image, you can immediately take this file and copy it to the App_Data folder for example.\n\n## B﻿e aware\n\nThe earlier described process will allow you to create a synchronization process which can pull content from any environment and push it as part of your  deployment.\n\nThere are however a couple of catches to this process. When you’re trying to synchronize large amounts of content, you will bump into certain (performance) limitations of Sitecore.\n\nSo far, we have seen that when you try to pull content from Sitecore, it will use a lot of its  memory resources available, even to the point where it runs out of memory and Sitecore may restart.\n\nTo circumvent this issue, try and create SCS modules which have a limited scope of content it will pull. If possible, you can also decide to give your CM instance access to more memory. With the process we have in place, it seems that 6-8GB of memory is required for this process to run smoothly.\n\nAnother option you can try is to build in a retry policy to your serialization pull commands. You can do this in your Azure DevOps pipeline task my specifying the *retryCountOnTaskFailure* option as shown below.\n\n```yaml\n  - task: DotNetCoreCLI@2\n    displayName: Sitecore ser pull\n    retryCountOnTaskFailure: 2\n    inputs:\n      command: 'custom'\n      custom: 'sitecore'\n      arguments: 'ser pull -i Content.Corporate'\n```\n\n## C﻿onclusion\n\nIt is clear that Sitecore’s more recently introduced APIs and tooling offers us a lot more flexibility and features to work with. This opens the door to building amazing features and process for our customers and get the most out of the Sitecore platform.",
  "seoDescription": "Automate content synchronization between Sitecore environments using Item as Resources, the Sitecore CLI and Azure DevOps"
}