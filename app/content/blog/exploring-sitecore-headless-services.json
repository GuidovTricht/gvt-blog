{
  "publishedAt": "07-17-2021",
  "title": "Exploring Sitecore Headless Services",
  "content": "A while ago I wanted to test the possibilities with Sitecore Headless and in the mean time also learn a new platform and even language.\nI decided to build a simple mobile app based on content coming from Sitecore's Headless Services APIs.\nIn this and following blog posts I want to share the knowledge I gathered building a simple Flutter Mobile App using content and tracking functionalities from Sitecore XP.\n\nIn this post I will take a look at what Sitecore Headless Services has to offer us in terms of endpoints and functionalities, looking at how we could use these to build an actual Mobile App.\n\n## Architecture\n\nMany know of JSS and the fairly new ASP.NET Core Rendering Host, but those frameworks could be considered as just examples. Both frameworks are built on top of the same APIs from Sitecore's Headless Services.\nTo fully understand the possibilities, let's see which APIs we can utilize to build our headless platform.\n\n![](/images/uploads/sitecore-headless-connection-points.png)\n\nIn above diagram we can see that Sitecore has multiple connection points, all being \n\n1. **Layout Service**; an API that can be used to get content and page structure information.\n2. **GraphQL**; GraphQL based APIs you can use to get fetch all details from any Sitecore item, including search capabilities.\n3. **Tracking APIs**; an API which can track and trigger goals, events, outcomes and page views.\n4. **xConnect**; Sitecore's abstraction layer around the xDB, which also offers OData APIs to create, read and update user interactions.\n5. **Custom**; There will always be a need for custom APIs as not all of Sitecore's Experience Platform capabilities are reachable through APIs and there is of course always a level of client specific custom functionalities we need to build in a Sitecore platform.\n\nLet's see which of these endpoints we can use for different purposes, serving content and tracking a user's behavior.\n\n## Content\n\nThe first thing we want to do, is show content in our App. There are two possible integrations we can build to make this happen, using the Layout Service or using GraphQL.\nThe Layout Service response is meant to return a JSON response object containing a full structure of how a page should be organized, which components are used and in which placeholders they are contributed.\nThe GraphQL API on the other side does not return this structured JSON, instead it just returns fields from Sitecore items in the way you configure it. For this reason, building an App based on the Layout Service would be the logical thing to do.\nThis does not mean the GraphQL API is useless. We can use GraphQL for serving other, structured kind of content, like a dictionary.\n\nThe Sitecore JSS site has some pretty detailed documentation about the inner workings of the Layout Service: https://jss.sitecore.com/docs/fundamentals/services/layout-service\nIn our case we want to focus on doing a request to the Layout Service and then using its response to build our App layout.\nThe API is (by default) using the following URL: /sitecore/api/layout/render/jss\nThis API requires a couple query string parameters (the following is taken from the JSS documentation)\n/sitecore/api/layout/render/jss?item=\\[path]&sc_lang=\\[language]&sc_apikey=\\[key]\n\n| Parameter | Description                                                                 |\n| --------- | --------------------------------------------------------------------------- |\n| item      | The path to the item, relative to the context site's home item or item GUID |\n| sc_lang   | The language version                                                        |\n| sc_apikey | An SSC API Key required to perform Layout Service requests.                 |\n| sc_site   | The name of the context site.                                               |\n\nIf we want to do a request to the homepage, the URL would look something like this:\n/sitecore/api/layout/render/jss?item=/&sc_lang=en&sc_apikey={00000000-0000-0000-0000-000000000000}\n\nThe response is a JSON object with one top-level object, \"sitecore\", and in that two other objects, \"context\" and \"route\".\n\n```json\n{\n  \"sitecore\": {\n    \"context\": {\n\t …\n    },\n    \"route\": {\n\t …\n    }\n  }\n}\n```\n\nThe context object contains some contextual properties, like the requested page, site name and language.\nThe route object is the one we can use to build our page, it contains a multi-level structure of all things related to the page Sitecore item and the Final Layout field converted to JSON instead of XML.\nThe Route object contains a list of placeholders as defined in Sitecore and in the Placeholder objects we can found our different renderings/components with all their fields and optionally extra placeholders.\n\n```json\n{\n    \"route\": {\n        \"name\": \"Home\",\n        \"displayName\": \"Home\",\n        \"fields\": {\n            \"NavigationTitle\": {\n                \"value\": \"Home\"\n            }\n        },\n        \"databaseName\": \"web\",\n        \"deviceId\": \"fe5d7fdf-89c0-4d99-9aa3-b5fbd009c9f3\",\n        \"itemId\": \"6ef11188-4b00-443c-8828-4ed3a68be665\",\n        \"itemLanguage\": \"en\",\n        \"itemVersion\": 1,\n        \"layoutId\": \"2218ad4f-87c8-4686-9c44-d36d509562d6\",\n        \"templateId\": \"49588140-2f59-4f56-ae5a-e3fb922ac29f\",\n        \"templateName\": \"Home Page\",\n        \"placeholders\": {\n            \"header\": [\n                {\n                    \"uid\": \"7d4f689f-208c-4ea3-88ba-0bc6e615771e\",\n                    \"componentName\": \"Header\",\n                    \"dataSource\": \"\",\n                    \"params\": {},\n                    \"fields\": {\n                        \"navItems\": [\n                            {\n                                \"url\": \"/en/\",\n                                \"isActive\": true,\n                                \"title\": \"Home\"\n                            },\n                            {\n                                \"url\": \"/en/Products\",\n                                \"isActive\": false,\n                                \"title\": \"Products\"\n                            },\n                            {\n                                \"url\": \"/en/Services\",\n                                \"isActive\": false,\n                                \"title\": \"Services\"\n                            }\n                        ]\n                    }\n                }\n            ],\n            \"main\": [\n                {\n                    \"uid\": \"bb562955-2cf5-4a57-b6c7-ddf2278ec0e0\",\n                    \"componentName\": \"HeroBanner\",\n                    \"dataSource\": \"{01ffd680-39fa-4d03-9e0c-7ae0dbf05747}\",\n                    \"params\": {},\n                    \"fields\": {\n                        \"Image\": {\n                            \"value\": {\n                                \"src\": \"https://placekitten.com/600/300\",\n                                \"alt\": \"Example Site\",\n                                \"width\": \"1920\",\n                                \"height\": \"510\"\n                            }\n                        },\n                        \"Subtitle\": {\n                            \"value\": \"Lorem Ipsum Dolor Sit Amet\"\n                        },\n                        \"Title\": {\n                            \"value\": \"Example Site\"\n                        }\n                    }\n                }\n            ],\n            \"footer\": [\n                {\n                    \"uid\": \"66b647e6-3d33-45ef-af06-ebb2175bc56b\",\n                    \"componentName\": \"Footer\",\n                    \"dataSource\": \"\",\n                    \"params\": {},\n                    \"fields\": {\n                        \"footerText\": \"Copyright\"\n                    }\n                }\n            ]\n        }\n    }\n}\n```\n\n## Personalization\n\nOne of the biggest reasons for Sitecore's clients to choose Sitecore is, or has been, the xDB capabilities to personalize and optimize a user's experience on their website.\nEnabling the content editor to keep using these functionalities in a Sitecore Headless scenario might seem a little problematic, because page are no longer directly being served by the CD role. However this does not mean that it doesn't work anymore.\n\nThe Layout Service is capable of personalizing and A/B testing renderings and pages like we have been used to in the past. Personalization rules still take affect when the Layout Service determines the output of the Route object, returning different renderings or data sources as needed.\nPageview tracking also still works. Instead of CD servers tracking these visits, the Layout Service is capable of tracking the API requests as pageviews (which can be enabled/disabled).\nApart from the page visits, we probably also want to track some goals. As pageview tracking works, tracking page goals will also work, but sometimes we want to track goals, page events and outcomes in a different way. For this purpose Sitecore Headless Services also has a Tracking API.\nThe JSS documentation has a page explaining how you can enable and use it in a JSS App (https://jss.sitecore.com/docs/fundamentals/services/tracking), but how to use it in different scenarios is still a bit vague after reading it.\n\nSo far I have found that there are two APIs we can use:\n\n1. An event API at /sitecore/api/jss/track/event?sc_apikey=\\[key]\n2. An API to flush the user's session at /sitecore/api/jss/track/flush?sc_apikey=\\[key]\n\nTo track an goal we can use that first API to send a JSON object in a POST request.\nThe JSON object looks something like this:\n\n```json\n{\n\t\"goalId\": \"[goal ID]\"\n}\n```\n\nThe JSON object determines what kind of event you trigger, here are some examples:\n\n**Goal**\n\n```json\n{\n\t\"goalId\": \"[goal ID]\"\n}\n```\n\n**Outcome**\n\n```json\n{\n\t\"outcomeId\": \"[outcome ID]\",\n\t\"currencyCode\": \"[currency code]\",\n\t\"monetaryValue\": \"[monetary value]\"\n}\n```\n\n**Page Event**\n\n```json\n{\n\t\"pageId\": \"[page ID]\",\n\t\"url\": \"[url]\"\n}\n```\n\n**Campaign**\n\n```json\n{\n\t\"campaignId\": \"[campaign ID]\"\n}\n```\n\n### Cookies\n\nFor tracking to work, cookies are used and need to be stored. This is the same approach as used in an MVC based Sitecore platform, where a session cookie is stored in a user's browser to identify the user. In the session object itself the page visits, goals, etc. are being stored until they are pushed to xDB.\n\nThis is however something which won't work out-of-the-box in a headless scenario unless it is the browser doing the Layout Service requests.\nSo you need to make sure to store the cookies somewhere in your App's session storage or direct it back to the browser in case of a browser based application, like the Rendering Host does.\n\nIn the next post we will take a look at how we could utilize these APIs and features and start building a Flutter App.",
  "seoDescription": "In this post I will take a look at what Sitecore Headless Services has to offer us in terms of endpoints and functionalities, which possibilities are there to extract content from Sitecore, and how can we track user behavior through APIs as well as looking at how we could use these to build an actual Mobile App."
}