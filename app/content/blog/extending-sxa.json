{
  "publishedAt": "07-26-2020",
  "title": "Extending SXA",
  "content": "<!--StartFragment-->\n\nThe past few months I have been working a lot with Sitecore Experience Accelerator and, as with every module or given functionality, I wanted to extend it.\\\nSitecore's SXA offers a lot of functionalities, so you want to reuse a lot of that. Things like a map component, search results and filter are great components to reuse but, as with a lot of things, it probably wont entirely fit the needs of your client. In order to completely be able to extend these components you also need to be able to extend or overwrite the JavaScript of those components. However, you don't want to be overwriting the actual files and renderings as they will be overwritten again when you upgrade SXA.\n\nThere are two reasons I wanted to be able to assign SXA Base Themes to specific renderings.\nFirst of all because we don't want to load all the JS on every page, this to minimize the page size and optimizing frontend performance. Secondly to more easily clone SXA renderings and replace their JS with customized JS.\n\nSXA uses a pipeline 'assetService' to render all the required asset includes on a page. This is being used for loading all the grid and theme assets for example, both the CSS and JS.\n\n```xml\n<assetService patch:source=\"Sitecore.XA.Feature.Composites.config\">\n  <processor type=\"Sitecore.XA.Feature.Composites.Pipelines.AssetService.AddGridTheme, Sitecore.XA.Feature.Composites\" resolve=\"true\"/>\n  <processor type=\"Sitecore.XA.Feature.SiteMetadata.Pipelines.AssetService.AddMetaPartialDesignTheme, Sitecore.XA.Feature.SiteMetadata\" resolve=\"true\" />\n  <processor type=\"Sitecore.XA.Foundation.Editing.Pipelines.AssetService.AddEditingTheme, Sitecore.XA.Foundation.Editing\" resolve=\"true\" />\n  <processor type=\"Sitecore.XA.Foundation.Editing.Pipelines.AssetService.AddHorizonEditingTheme, Sitecore.XA.Foundation.Editing\" resolve=\"true\" />\n  <processor type=\"Sitecore.XA.Foundation.Grid.Pipelines.AssetService.AddGridTheme, Sitecore.XA.Foundation.Grid\" resolve=\"true\" />\n  <processor type=\"Sitecore.XA.Foundation.Theming.Pipelines.AssetService.AddTheme, Sitecore.XA.Foundation.Theming\" resolve=\"true\" />\n  <processor type=\"Sitecore.XA.Foundation.Theming.Pipelines.AssetService.AddThemeExtensions, Sitecore.XA.Foundation.Theming\" resolve=\"true\" />\n  <processor type=\"Sitecore.XA.Feature.Overlays.Pipelines.AssetService.AddTheme, Sitecore.XA.Feature.Overlays\" resolve=\"true\" />\n</assetService>\n```\n\nEach processor in this pipeline looks for assets needed and adds them to the AssetsList in the processor args.\n\nIn the pipeline we also have access to the PageContext, which contains a list of all renderings on that page.\n\n```csharp\n  foreach (Rendering rendering in GetRenderingsList())\n```\n\nBy adding an extra Treelist field to the Controller rendering template, we can associate Base Themes to specific renderings.\n\n```csharp\nSitecore.Data.Fields.MultilistField baseThemes = item.Fields[Templates.RenderingAssets.Fields.BaseThemes];\n\nforeach (var theme in baseThemes.GetItems())\n{\n  if (theme == null || assetsList.Any(i => i is ThemeInclude assetInclude && assetInclude.ThemeId == theme.ID))\n    continue;\n  \n  renderingThemes.Add(new ThemeInclude\n    {\n      Name = theme.Name,\n      ThemeId = theme.ID,\n      Theme = theme\n  });\n}\n```\n\nWithin a custom processor in the assetService pipeline we can then pull those Base Themes and add the assets to the AssetsList if not already present. The end result:\n```csharp\npublic class AddRenderingAssets : AddAssetsProcessor\n{\n  public override void Process(AssetsArgs args)\n  {\n    var assetsList = args.AssetsList as List<AssetInclude> ?? new List<AssetInclude>();\n    foreach (Rendering rendering in GetRenderingsList())\n    {\n      var item = GetRenderingItem(rendering);\n\n      if (item == null)\n        continue;\n\n      var cacheKey = $\"{Context.Database.Name}#{item.ID}#{this.Context.Device.ID}#RenderingAssets\";\n      var renderingThemes = (List<AssetInclude>)HttpRuntime.Cache.Get(cacheKey);\n\n      if (renderingThemes == null)\n      {\n        renderingThemes = new List<AssetInclude>();\n\n        Sitecore.Data.Fields.MultilistField baseThemes = item.Fields[Templates.RenderingAssets.Fields.BaseThemes];\n        foreach (var theme in baseThemes.GetItems())\n        {\n          if (theme == null || assetsList.Any(i => i is ThemeInclude assetInclude && assetInclude.ThemeId == theme.ID))\n            continue;\n\n          renderingThemes.Add(new ThemeInclude\n          {\n            Name = theme.Name,\n            ThemeId = theme.ID,\n            Theme = theme\n          });\n        }\n\n        if (global::Sitecore.Context.PageMode.IsNormal && rendering.RenderingItem.Caching.Cacheable)\n          this.CacheRenderingAssets(cacheKey, renderingThemes);\n      }\n\n      assetsList.AddRange(renderingThemes);\n    }\n  }\n\n  private List<Rendering> GetRenderingsList()\n  {\n    return global::Sitecore.Mvc.Presentation.PageContext.Current.PageDefinition.Renderings;\n  }\n\n  private Item GetRenderingItem(Rendering rendering)\n  {\n    if (rendering.RenderingItem == null)\n    {\n      Log.Warn($\"rendering.RenderingItem is null for {rendering.RenderingItemPath}\", this);\n      return null;\n    }\n\n    return rendering.RenderingItem.InnerItem;\n  }\n\n  private void CacheRenderingAssets(string key, List<AssetInclude> assets)\n  {\n    if (assets == null || !assets.Any())\n      return;\n    HttpRuntime.Cache.Add(key, assets, null, Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration, CacheItemPriority.Normal, null);\n  }\n}\n\nSmall changes like these help SXA become even more flexible and bend it to the needs of your website and team.",
  "seoDescription": "Small changes to make SXA renderings more flexible in rendering assets specific to renderings."
}