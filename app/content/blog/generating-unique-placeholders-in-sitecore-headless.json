{
  "publishedAt": "03-31-2022",
  "title": "Generating unique placeholders in Sitecore Headless",
  "content": "For a while now I have been working with Sitecore Headless, to be precise the .NET Rendering Host version of it. It has been a great experience so far, but every now and then I do come across a feature which I would like existed in the Headless approach but is not supported. One of those things is generated placeholders.\\\nI know dynamic placeholders is supported; placeholders will get a unique ID based on the rendering they are rendered in. But this is not enough if I want to display a placeholder with the same key multiple times in a rendering, which I would want to do when building a tab component for example.\\\nIn this post I will share some background on why this is not supported right now and how you can make it more flexible. \n\n## The problem\n\nWhen you open the Experience Editor, the page is displayed including different frames and chromes to make the Experience Editor function.\\\nTo understand the problem, we need to understand the difference in data flow on how the Experience Editor page is being rendered. Let's first start by looking at the original MVC approach.\n\nIn the MVC flow, it is one and the same application generating the page structure and has access to the HtmlHelpers which generate the placeholders. I tried to put this flow in a simple diagram:\n\n![Data flow in Sitecore MVC](/images/uploads/rh-dynamic-placeholders-mvc.png \"Data flow in Sitecore MVC\")\n\nWhile Sitecore is generating the page and including the chromes, it knows everything there is to know about the context of the to be rendered page, rendering and placeholder. This makes it possible to generate any placeholder key, add it to the HTML and still know what kind of chromes to add around it.\n\nIf we compare this to the Headless variant, then the diagram looks something like this:\n\n![Data flow in Sitecore Headless](/images/uploads/rh-dynamic-placeholders-headless.png \"Data flow in Sitecore Headless\")\n\nIn this scenario, there are 2 applications involved. Sitecore knows only the content structure, based on that it generates the JSON for the Layout Service including the placeholders it knows should exist in each component.\\\nThat JSON is then send to the Rendering Host to convert it into an HTML page, but at the time of generating the HTML it only knows what to render in specific placeholders based on what the JSON told it to. So, the Rendering Host is missing context which it would need to be able to generate dynamic and always unique placeholders.\n\n## Improving the solution\n\nI don't think it is (right now) possible to build truly dynamic placeholders in the Headless development approach, but we can make it a little more flexible.\\\nIn my case I had to build a tabs component. A content editor should be able to add new tabs to the component and then be able to add any other component to that specific tab. So, for every tab created a different placeholder should be rendered. In this scenario we know which tabs should be displayed based on the content and data source selected on the component, so we can use that to generate extra placeholders in Layout Service response.\n\nOn the Layout Service side, we need to make 2 changes.\\\nThe first one is in the Sitecore.LayoutService.Placeholders.DynamicPlaceholdersResolver. This is the place where the out of the box functionalities generate unique IDs for the dynamic placeholders. This will also be the place where we can add logic to generate extra placeholders. My version of the override for the GetPlaceholderDefinitions method looks like this:\n\n```csharp\nprotected override IList<PlaceholderDefinition> GetPlaceholderDefinitions(Rendering ownerRendering, PlaceholderItem placeholderItem)\n{\n    Assert.ArgumentNotNull(ownerRendering, nameof(ownerRendering));\n    Assert.ArgumentNotNull(placeholderItem, nameof(placeholderItem));\n    if (string.IsNullOrEmpty(ownerRendering?.Placeholder))\n    {\n        var emptyResult = new PlaceholderDefinition[1]\n        {\n            new PlaceholderDefinition()\n            {\n                OwnerRendering = ownerRendering,\n                PlaceholderItem = placeholderItem,\n                Path = placeholderItem.Key\n            }\n        };\n      \n        return emptyResult;\n    }\n  \n    int placeholderCount = this.GetPlaceholderCount(ownerRendering, placeholderItem);\n    // Store the original DynamicPlaceholder because we can use it as a basis for our generated placeholders.\n    var dynamicResult = new DynamicPlaceholderKeysResolver().GetDynamicKeys(placeholderItem.Key, ownerRendering, placeholderCount, 0).Select(key =>\n    {\n        string str = StringUtil.EnsurePrefix('/', FileUtil.MakePath(ownerRendering.Placeholder, key, '/'));\n        return new PlaceholderDefinition()\n        {\n            OwnerRendering = ownerRendering,\n            PlaceholderItem = placeholderItem,\n            Path = str\n        };\n    }).ToList();\n    \n    // If \"GenerateChildPlaceholders\" is set, we want to generate a placeholder for each Child item of the rendering Data Source\n    var generateChildPlaceholders = ownerRendering.RenderingItem?.Parameters?.Contains(\"GenerateChildPlaceholders=1\") ?? false;\n    if (generateChildPlaceholders && dynamicResult.Any() && (ownerRendering.Items?.FirstOrDefault()?.Children.Any() ?? false))\n    {\n        var basePlaceholderDefinition = dynamicResult.FirstOrDefault();\n        if (basePlaceholderDefinition != null)\n        {\n            var basePath = basePlaceholderDefinition.Path.Replace(basePlaceholderDefinition.Path.Split('/').Last(), \"\");\n            var childList = new List<PlaceholderDefinition>();\n            // For each child item of the datasource we will add an extra placeholder. These placeholders are based on the original dynamic placeholder, with the only difference being the Path property of the PlaceholderDefinition.\n            foreach (var item in ownerRendering.Items.FirstOrDefault().Children.ToList())\n            {\n                childList.Add(new PlaceholderDefinition\n                              {\n                                  OwnerRendering = ownerRendering,\n                                  PlaceholderItem = placeholderItem,\n                                  Path = $\"{basePath}{placeholderItem.Key.TrimEnd('*').ToLower()}-{item.ID.ToString().ToLower()}\"\n                              });\n            }\n            return childList;\n        }\n    }\n  \n    return dynamicResult;\n}\n```\n\nIn above additional code I check for a setting \"GenerateChildPlaceholders\". This is set on the parameters field of the rendering item. An improvement would be to make this into an actual checkbox instead of freely adding it to some text field.\n\nThe second part is making sure the placeholder path is being used in the JSON result instead of the name, as otherwise the placeholders keep overwriting each other in the array.\\\nThese placeholders are added in the Sitecore.JavaScriptServices.ViewEngine.LayoutService.Serialization.PlaceholderTransformer.\\\nThe piece of code we need to change is in the TransformPlaceholders, where the placeholders are added to an array:\n\n```csharp\ndictionary[placeholder.Name] = ...\n```\n\nBut we only want to do this for placeholders which were added by our earlier customization, so we also need to add a check in the TransformPlaceholderElement method.\\\nThe result looks something like this:\n\n```csharp\npublic IDictionary<string, object> CustomTransformPlaceholders(IList<RenderedPlaceholder> placeholders)\n{\n    if (placeholders == null)\n        return new Dictionary<string, object>();\n  \n    IDictionary<string, object> dictionary = new ExpandoObject();\n    foreach (RenderedPlaceholder placeholder in placeholders)\n        // Using the placeholder.Path instead of placeholder.Name to be able to use multiple placeholders of the same type in a single component.\n        dictionary[placeholder.Path.Split('/').Last()] = placeholder.Elements.Select(this.TransformPlaceholderElement);\n    return dictionary;\n}\n\npublic override object TransformPlaceholderElement(RenderedPlaceholderElement element)\n{\n    RenderedJsonRendering renderedJsonRendering = element as RenderedJsonRendering;\n    if (renderedJsonRendering == null)\n    {\n        return element;\n    }\n\n    dynamic val = new ExpandoObject();\n    val.uid = renderedJsonRendering.Uid;\n    val.componentName = renderedJsonRendering.ComponentName;\n    val.dataSource = renderedJsonRendering.DataSource;\n    val.@params = renderedJsonRendering.RenderingParams;\n  \n    if (renderedJsonRendering.Contents != null)\n    {\n        val.fields = renderedJsonRendering.Contents;\n    }\n\n    if (renderedJsonRendering.Placeholders != null && renderedJsonRendering.Placeholders.Count > 0)\n    {\n        // If the Rendering Parameters field contains \"GenerateChildPlaceholders\" we want to apply custom logic\n        // This can be improved by making it a specific (checkbox) field on the Rendering Template or something similar\n        if (renderedJsonRendering.RenderingParams.TryGetValue(\"GenerateChildPlaceholders\", out string paramVal)\n            && !string.IsNullOrEmpty(paramVal) && paramVal.Equals(\"1\"))\n            val.placeholders = CustomTransformPlaceholders(renderedJsonRendering.Placeholders);\n        else\n            val.placeholders = TransformPlaceholders(renderedJsonRendering.Placeholders);\n    }\n\n    return val;\n}\n```\n\nWithin this TransformPlaceholderElement method we also want to do a check on the existence of a \"GenerateChildPlaceholders\" to see if we need to trigger our customized code. However, this is a different source of the setting compared to the GetPlaceholderDefinitions customization because the context is different.\\\nWithin the PlaceholderTransformer we only have knowledge about the rendering, some basic fields about the placeholder and the elements in it. We do not have access or even know which rendering is being rendered here. So, to fix this we need to set this \"GenerateChildPlaceholders\" as a field on the rendering parameters of the rendering, which can easily be done with a base template including this field as a checkbox which is set to be enabled by default.\n\nThese changes to the Layout Service result in the following JSON for my Tabs component (each placeholder contains multiple different components):\n\n```json\n{\n    \"uid\": \"06487de2-8c65-49d8-a77b-a553d1b40caa\",\n    \"componentName\": \"Tabs\",\n    \"dataSource\": \"{3C357E6A-F6B1-4679-BCD0-0ECC7423EF46}\",\n    \"params\": {\n        \"GenerateChildPlaceholders\": \"1\"\n    },\n    \"fields\": {\n        \"items\": [\n            {\n                \"id\": \"6717e695-25ab-4081-ac44-0feebed3df60\",\n                \"url\": \"/Shared-Content/Tabs/Tabs-Example/Tab-1\",\n                \"name\": \"Tab 1\",\n                \"displayName\": \"Tab 1\",\n                \"fields\": {\n                    \"Title\": {\n                        \"value\": \"Tab 1\"\n                    }\n                }\n            },\n            {\n                \"id\": \"a36af741-c233-4787-ad45-757821bfb2cc\",\n                \"url\": \"/Shared-Content/Tabs/Tabs-Example/Tab-2\",\n                \"name\": \"Tab 2\",\n                \"displayName\": \"Tab 2\",\n                \"fields\": {\n                    \"Title\": {\n                        \"value\": \"Tab 2\"\n                    }\n                }\n            }\n        ]\n    },\n    \"placeholders\": {\n        \"dynamic-tab-{6717e695-25ab-4081-ac44-0feebed3df60}\": [...],\n        \"dynamic-tab-{a36af741-c233-4787-ad45-757821bfb2cc}\": [...]\n    }\n}\n```\n\nOn the Rendering Engine side, we need to make one change as well, which is actually more of a bug fix.\\\nThe problem is that the *sc-placeholder* tag helper at some point, while rendering placeholders, changes its context component to the component it renders inside the placeholder. This is not a problem in the out of the box functionality, but in our case, it is because we want to render more than just one placeholder in a component.\\\nDue to methods being private in the original Placeholder Tag Helper, we need to copy all of it instead of being able to just override a single method. The result looks like:\n\n```csharp\n[HtmlTargetElement(\"custom-placeholder\")]\npublic class PlaceholderTagHelper : TagHelper\n{\n    private readonly IComponentRendererFactory _componentRendererFactory;\n    private readonly IEditableChromeRenderer _chromeRenderer;\n\n    [HtmlAttributeNotBound]\n    [ViewContext]\n    public ViewContext ViewContext { get; set; }\n    public string Name { get; set; }\n\n    public PlaceholderTagHelper(IComponentRendererFactory componentFactory, IEditableChromeRenderer chromeRenderer)\n    {\n        _componentRendererFactory = componentFactory;\n        _chromeRenderer = chromeRenderer;\n    }\n\n    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)\n    {\n        string placeholderName = Name;\n        if (string.IsNullOrEmpty(placeholderName))\n        {\n            output.Content.SetHtmlContent(\"<!-- \" + Resources.Warning_PlaceholderNameWasNotDefined + \" -->\");\n            return;\n        }\n\n        output.TagName = string.Empty;\n        if (ViewContext == null)\n        {\n            throw new NullReferenceException(Resources.Exception_ViewContextCannotBeNull);\n        }\n\n        ISitecoreRenderingContext renderingContext = ViewContext?.HttpContext.GetSitecoreRenderingContext();\n        if (renderingContext == null)\n        {\n            throw new NullReferenceException(Resources.Exception_SitecoreLayoutCannotBeNull);\n        }\n\n        Placeholder placeholderFeatures = GetPlaceholderFeatures(placeholderName, renderingContext);\n        if (placeholderFeatures == null)\n        {\n            output.Content.SetHtmlContent(\"<!-- \" + Resources.Warning_PlaceholderWasNotDefined + \" -->\");\n            return;\n        }\n\n        bool foundPlaceholderFeatures = false;\n        foreach (IPlaceholderFeature item in placeholderFeatures)\n        {\n            if (item != null)\n            {\n                foundPlaceholderFeatures = true;\n                Component component = item as Component;\n                IHtmlContent htmlContent;\n\n                if (component == null)\n                {\n                    EditableChrome editableChrome = item as EditableChrome;\n                    htmlContent = editableChrome == null ? HtmlString.Empty : _chromeRenderer.Render(editableChrome);\n                }\n                else\n                {\n                    // BUGFIX\n                    // Take a copy of the Component and re-set it on the renderingContext after rendering the component.\n                    // This fixes a bug where the next placeholder in the outer component would have a wrong Component context.\n                    var outerComponent = renderingContext.Component;\n                    renderingContext.Component = component;\n                    htmlContent = await RenderComponent(renderingContext, ViewContext).ConfigureAwait(continueOnCapturedContext: false);\n                    renderingContext.Component = outerComponent;\n                }\n                output.Content.AppendHtml(htmlContent);\n            }\n        }\n\n        if (!foundPlaceholderFeatures)\n        {\n            output.Content.SetHtmlContent(\"<!-- \" + Resources.Warning_PlaceholderWasEmpty(placeholderName) + \" -->\");\n        }\n    }\n\n    private Task<IHtmlContent> RenderComponent(ISitecoreRenderingContext renderingContext, \\[AllowNull] ViewContext viewContext)\n    {\n        if (renderingContext == null || viewContext == null)\n        {\n            throw new NullReferenceException(Resources.Exception_RenderingContextCannotBeNull);\n        }\n\n        Component component = renderingContext.Component;\n        if (component == null)\n        {\n            throw new NullReferenceException(Resources.Exception_RenderingContextComponentCannotBeNull);\n        }\n\n        return _componentRendererFactory.GetRenderer(component).Render(renderingContext, viewContext);\n    }\n\n    private static Placeholder GetPlaceholderFeatures(string placeholderName, ISitecoreRenderingContext renderingContext)\n    {\n        Placeholder value = null;\n        if (renderingContext.Component != null)\n        {\n            renderingContext.Component!.Placeholders.TryGetValue(placeholderName, out value);\n        }\n\n        if (value == null || !value.Any())\n        {\n            (renderingContext.Response?.Content?.Sitecore?.Route)?.Placeholders.TryGetValue(placeholderName, out value);\n        }\n\n        return value;\n    }\n}\n```\n\nIn your components you can then use the <custom-placeholder /> tag helper to generate placeholders.\\\nUsing this in my Tabs component results in the following ViewComponent:\n\n```razor\n@model Tabs\n\n<div class=\"container tabs\">\n    @foreach(var tab in Model.Children)\n    {\n        <div class=\"tab-item\">\n            <div class=\"tab-header\">               \n                <h3 asp-for=\"@tab.Target.Title\"></h3>\n                <button></button>\n            </div>\n            <div class=\"tab-body\" style=\"@bodyStyle\">\n                <custom-placeholder name=\"dynamic-tab-@tab.Id.ToString(\"B\")\"></custom-placeholder>\n            </div>\n        </div>\n    }\n</div>\n```\n\nAs you can see, you then need to set the placeholder's name to the same value as was generated on the Layout Service side. This follows the following structure: \\[placeholder key]-\\[sitecore item ID]",
  "seoDescription": "I'm sharing an aproach on how to generate additional unique placeholders in a Sitecore Headless scenario when working with the .NET Rendering Host."
}
