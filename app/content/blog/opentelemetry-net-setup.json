{
  "publishedAt": "04-22-2025",
  "title": "OpenTelemetry - .NET Setup",
  "content": "During the past couple of weeks, I have been working on optimizing the monitoring and tracing setup for one of my projects. We were already using Prometheus and Grafana, but didn't really take advantage of the full feature set.\n\nIn an effort to build in more tracing capabilities and gather more data for easier troubleshooting of issues, I setup OpenTelemetry for the .NET (Core) applications part of the platform.\n\nIn this article I'll describe how to install the OpenTelemetry SDK in .NET and how to extend your code to expose more data in the metrics and tracing output.\n\n## Install OpenTelemetry SDK\n\nThe .NET OpenTelemetry SDK consists of multiple NuGet packages that enable different features.\\\nTo install the base setup, you will want to install the following packages\n\n* OpenTelemetry.Extensions.Hosting → Base package for exposing a /metrics endpoint\n* OpenTelemetry.Instrumentation.AspNetCore → Base package to expose Asp.NET Core metrics in the /metrics endpoint\n* OpenTelemetry.Exporter.Console → Base package to log metrics and tracing to the console output\n\nOther packages that may be of interest are\n\n* OpenTelemetry.Exporter.OpenTelemetryProtocol → Package enabling tracing exporting to OpenTelemetry capable tooling, such as .NET Aspire dashboard and Jaeger\n* OpenTelemetry.Instrumentation.Http → Package to enable HttpClient metrics to be output in metrics and tracing\n* OpenTelemetry.Instrumentation.Process → Package to enable process metrics to be output from the /metrics endpoint\n* OpenTelemetry.Instrumentation.Runtime → Package to enable runtime metrics to be output from the /metrics endpoint\n* OpenTelemetry.Instrumentation.StackExchangeRedis → Package to enable Redis session storage metrics to be output in metrics and tracing\n\nThe versions of these package you need to install is based on the .NET version you use. Note that many OpenTelemetry packages are marked as prerelease version.\n\n* For .NET 6, use package version <= 1.9.0\n* For .NET 8+, use package versions > 1.11.0\n\n## Enable OpenTelemetry\n\nTo enable the OpenTelemetry SDK, we first need to register it with DependencyInjection in the IServiceCollection.\n\n```csharp\n// Register OpenTelemetry\nvar otel = services.AddOpenTelemetry()\n    .ConfigureResource(resource => resource\n        // Specify a unique name for you application type\n        // this will be used to separate tracing logs\n        .AddService(\"[Application name]\"));\n \n// Enable Metrics\notel.WithMetrics(metrics => metrics\n    .AddAspNetCoreInstrumentation()\n    .AddHttpClientInstrumentation()\n    // Enable any additional Instrumentations\n    // .AddRuntimeInstrumentation()\n    // .AddProcessInstrumentation()\n    // Enable the Prometheus Exporter\n    .AddPrometheusExporter());\n \n// Enable Tracing Exporter\notel.WithTracing(tracing =>\n{\n    // Provide a unique application name which all the activities will be tagged with\n    tracing.AddSource(\"[Application name]\");\n    tracing.AddAspNetCoreInstrumentation();\n    tracing.AddHttpClientInstrumentation();\n    // Add any additional Instrumenations\n    // tracing.AddRedisInstrumentation();\n    // Specify where to export the traces to, like a Jaeger endpoint\n    tracing.AddOtlpExporter(otlpOptions =>\n    {\n        otlpOptions.Endpoint = new Uri(\"[Endpoint URL]\");\n        otlpOptions.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.HttpProtobuf;\n    });\n});\n```\n\nWith these services registered, all metrics will be gathered, and traces will be sent to the configured endpoint.\n\nThe last thing to do is to enable the /metrics endpoint, by add the Middleware in the IApplicationBuilder:\n\n```csharp\napp.UseOpenTelemetryPrometheusScrapingEndpoint();\n```\n\n## Tracing improvements\n\nOut of the box, tracing will be exported with a default set of tags. Depending on your application, you may want to customize this setup.\n\n### Filter requests\n\nYou may not want to export all requests to you application as traces, such as the /metrics or healthcheck requests.\\\nTo exclude these requests, you can configure filters in the tracing.AddAspNetCoreInstrumentation step:\n\n```csharp\ntracing.AddAspNetCoreInstrumentation(options =>\n{\n    options.Filter = (httpContext) =>\n    {\n        // Specify paths that you want to exclude\n        string[] filters = new string[] {\n            \"/liveness\",\n            \"/hc\",\n            \"/metrics\",\n            \"/js\",\n            \"/img\",\n        };\n \n        try\n        {\n            if (filters.Any(f => httpContext.Request.Path.Value.StartsWith(f)))\n            {\n                return false;\n            }\n            return true;\n        }\n        catch\n        {\n            return true;\n        }\n    };\n});\n```\n\n### Custom activity DisplayName and tags\n\nThe OpenTelemetry SDK will try to determine the routing tags and the name of an activity by using the HttpRequest and HttpResponse objects and the Route that was triggered during the request.\\\nWhen using wildcard Routes for example, you will want to customize these values so you can separate traces from each other.\n\nTo do so, you can use the EnrichWithHttpRequest and EnrichWithHttpResponse options in the tracing.AddAspNetCoreInstrumentation step:\n\n```csharp\ntracing.AddAspNetCoreInstrumentation(options =>\n{\n    options.EnrichWithHttpRequest = (activity, httpRequest) =>\n    {\n        // Customize tag values\n        activity.SetTag(\"http.route\", httpRequest.Path.Value);\n    };\n    options.EnrichWithHttpResponse = (activity, httpResponse) =>\n    {\n        // Customize the Sitecore .NET SDK route Display Name\n        if (activity.DisplayName.Contains(\"**sitecoreRoute\"))\n            activity.DisplayName = $\"{httpResponse.HttpContext.Request.Method} {httpResponse.HttpContext.Request.Path}\";\n    };\n});\n```\n\n### Adding Activities\n\nYou can break down traces into multiple smaller activities by using the Activity framework that is built into .NET.\n\nActivities are started from an ActivitySource. Since creating new instances of the ActivitySource object can be expensive, it is best to create one as a Singleton in your application.\\\nTake below InstrumentationSource for example which can be added to the IServiceCollection as a Singleton.\n\n```csharp\npublic sealed class InstrumentationSource : IDisposable\n{\n    internal const string ActivitySourceName = \"[Application name]\";\n \n    public InstrumentationSource()\n    {\n        string? version = typeof(InstrumentationSource).Assembly.GetName().Version?.ToString();\n        this.ActivitySource = new ActivitySource(ActivitySourceName, version);\n    }\n \n    public ActivitySource ActivitySource { get; }\n \n    public void Dispose()\n    {\n        this.ActivitySource.Dispose();\n    }\n}\n```\n\nWhenever you want to start a new activity, you can use the InstrumentationSource.ActivitySource like below.\n\n```csharp\nusing Activity activity = _instrumentationSource.ActivitySource.StartActivity(\"[Activity name]\");\n \n... perform activities here\n```\n\nAs Activity is Disposable, you will want to either create an instance in a using or dispose of it at the end of your method.\n\nYou will want to create Activities for expensive actions that take place during a thread.",
  "seoDescription": "I﻿n this article I'm describing how to install the OpenTelemetry SDK in .NET and how to extend your code to expose more data in the metrics and tracing output."
}