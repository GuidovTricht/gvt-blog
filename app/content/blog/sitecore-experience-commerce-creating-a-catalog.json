{
  "publishedAt": "10-23-2018",
  "title": "Sitecore Experience Commerce â€“ Creating a catalog",
  "content": "As there is not much online yet on how to create a catalog/product import in Sitecore Experience Commerce(XC) 9.0, I wanted to share a bit of code and thoughts on how we created it.\n\n## Where to start?\n\nSince there was not much info about creating a catalog import, either in documentation or online, we had to gather our knowledge in another way.\n\nWe knew that XC contained an out-of-the-box catalog export/import, so we decided to have a look at the code through decompiling the assemblies. By doing this we got a couple of architectural insights:\n\n* API controllers never run pipelines directly\n* Minions can watch Lists\n* There are Entity specific and generic pipelines, for example\n\n  * IGetCatalogPipeline\n  * IFindEntityPipeline\n* Sitecore XC uses the Sitecore XP OData API to get items, like translations and settings\n\nNext to that, another great help was digging through the tables in the two databases.\n\n![XC Table](/images/uploads/xc-table.png)\n\nIn this CatalogEntities table we can see each Entity has a couple of properties in the database:\n\n* Id: Each Entity has its own unique Id, composed of an Entity Prefix followed by something unique\n* EnvironmentId\n* Version\n* EntityVersion\n* Published\n* Entity: A JSON string containing all the details and properties of the Entity itself\n\nThese properties in the database together with the properties from the Entity JSON, give us a clear image on how to create these Entities, or at least which fields on the object you need to fill.\n\n## The creation flow\n\nWe want our catalog import to both handle the creation and update of categories and sellable items. This can be done by using the pipelines, minions and lists in Sitecore XC. So, what would this catalog import look like?\n\n![XC flow 1](/images/uploads/xc-flow-1.png)\n\nIn above flowchart you can see an example flow on how to create the import. As you can see we use the 'generic' IFindEntityPipeline to get the entities if they exist. We use this pipeline and not the GetCatalogPipeline for example because the latter one also gathers a lot of data which we don't need in these imports/updates, like pricing and inventory details.\n\nNow we want to make sure that we can also update the products from time to time, but don't want to run a full update/import command. If only one product has changed in the PIM, we only want to update that single product. To make this possible we add the Id's of the products to a List and process those Id's using a Minion.\n\n![XC flow 2](/images/uploads/xc-flow-2.png)\n\nThis Minion would then run another pipeline to update the product. Using a List here makes scaling the import process also possible, because you can spin-up multiple Environments/Minions to process the Id's.\n\n## The actual code\n\nI am not going to place all the code for this import inside this blog post, instead I created a GitHub repository to host an example implementation: <https://github.com/GuidovTricht/SitecoreCommerceProductImportExample> (Note that this example doesn't contain the List and Minion to create the SellableItems)\n\nBut I do want to point out some steps and code snippets. For example, on how to create an Entity. In the following snippet creating a Category.\n\n```csharp\npublic override async Task<SynchronizeCategoryArgument> Run(SynchronizeCategoryArgument arg, CommercePipelineExecutionContext context)\n{\n    Sitecore.Commerce.Plugin.Catalog.Category category = null;\n    var categoryId = $\"{CommerceEntity.IdPrefix<Sitecore.Commerce.Plugin.Catalog.Category>()}{arg.Catalog.Name}-{arg.ImportCategory.CategoryId.ProposeValidId()}\";\n\n    if (await _doesEntityExistPipeline.Run(\n        new FindEntityArgument(typeof(Sitecore.Commerce.Plugin.Catalog.Category), categoryId),\n        context.CommerceContext.GetPipelineContextOptions()))\n    {\n        category = await _findEntityPipeline.Run(new FindEntityArgument(typeof(Sitecore.Commerce.Plugin.Catalog.Category), categoryId), context.CommerceContext.GetPipelineContextOptions()) as Sitecore.Commerce.Plugin.Catalog.Category;\n    }\n    else\n    {\n        var createResult = await _createCategoryPipeline.Run(\n            new CreateCategoryArgument(arg.Catalog.Id, arg.ImportCategory.CategoryId.ProposeValidId(),\n                arg.ImportCategory.CategoryName, \"\"), context.CommerceContext.GetPipelineContextOptions());\n        category = createResult?.Categories?.FirstOrDefault(c => c.Id.Equals(categoryId));\n    }\n\n    Condition.Requires<Sitecore.Commerce.Plugin.Catalog.Category>(category)\n        .IsNotNull($\"{this.Name}: The Category could not be created.\");\n\n    arg.Category = category;\n\n    return arg;\n}\n```\n\nNotice that we used a couple of standard Helpers/Extensions like CommerceEntity.IdPrefix<>(), which returns the default prefix like we have seen in the database, and ProposeValidId(), which removes any non alphanumeric characters from the (id)string.\n\nIn the following snippet you can see how easy it is to add a list/enumerable of strings to an XC List:\n\n```csharp\nList<string> ids;\nvar addArg = new ListEntitiesArgument(ids, \"ProductUpdatesList\");\nawait _addListEntitiesPipeline.Run(addArg, context);\n```\n\nAnd in the last snippet what a Minion would look like which reads 10 Id's from the List each time it is run and then uses it to run a pipeline.\n\n```csharp\npublic class UpdateProductsMinion : Minion\n{\n    private ISynchronizeProductPipeline _synchronizeProductPipeline;\n    private IRemoveListEntitiesPipeline _removeListEntitiesPipeline;\n\n    public override void Initialize(IServiceProvider serviceProvider, ILogger logger, MinionPolicy policy, CommerceEnvironment environment, CommerceContext globalContext)\n    {\n        base.Initialize(serviceProvider, logger, policy, environment, globalContext);\n        _synchronizeProductPipeline = this.ResolvePipeline<ISynchronizeProductPipeline>();\n        _removeListEntitiesPipeline = this.ResolvePipeline<IRemoveListEntitiesPipeline>();\n    }\n\n    public override async Task<MinionRunResultsModel> Run()\n    {\n        var listCount = await this.GetListCount(this.Policy.ListToWatch);\n\n        this.Logger.LogInformation($\"{this.Name}-Review List {this.Policy.ListToWatch}: Count:{listCount}\");\n        var list = (await this.GetListIds<string>(this.Policy.ListToWatch, this.Policy.ItemsPerBatch)).IdList;\n\n        foreach (var id in list)\n        {\n            this.Logger.LogDebug($\"{this.Name}-Reviewing Pending Product Update: {id}\");\n\n            try\n            {\n                await _synchronizeProductPipeline.Run(\n                    new SynchronizeProductArgument { ExternalProductId = id },\n                    MinionContext.GetPipelineContextOptions());\n                this.Logger.LogInformation($\"{this.Name}: Product with id {id} has been updated\");\n\n                await _removeListEntitiesPipeline.Run(new ListEntitiesArgument(new List<string>(){ id }, this.Policy.ListToWatch), MinionContext.GetPipelineContextOptions());\n            }\n            catch (Exception ex)\n            {\n                this.Logger.LogError(ex, $\"{this.Name}: Product with id {id} could not be updated\");\n            }\n        }\n\n        return new MinionRunResultsModel\n        {\n            ItemsProcessed = this.Policy.ItemsPerBatch,\n            HasMoreItems = listCount > this.Policy.ItemsPerBatch\n        };\n    }\n}\n```",
  "seoDescription": "Sharing my thoughts on how to create a catalog import for Sitecore Experience Commerce (XC)"
}