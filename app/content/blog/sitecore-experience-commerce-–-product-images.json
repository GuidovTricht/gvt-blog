{
  "publishedAt": "1st Jun 2019",
  "title": "Sitecore Experience Commerce – Product images",
  "content": "One of the first things you’ll notice when looking at the catalog features in Sitecore Experience Commerce (XC) 9, that the product images will have to be uploaded in Sitecore Experience Platform (XP) and Sitecore XC only has to know the Sitecore Item IDs of these images. In itself a good architectural decision in my opinion, but once you start developing a product import of some sorts you’ll notice that there is no out-of-the-box solution for actually uploading images or other assets from XC into XP!\n\nLucky for us, Sitecore XC had to get Storefront settings from XP. These Storefront settings are settings about the shop you are running and contain settings like which fulfillment or payment options can be used. Sitecore used the [OData Item Service](https://doc.sitecore.com/developers/91/sitecore-experience-management/en/the-odata-item-service.html) for this, and the implementation they made can be easily reused. So lets create a Sitecore XC Plugin which utilizes these OData Services to upload images when importing your Catalog products.\n\n## Sitecore XP implementation\n\nThe first thing we will need to do, is create a custom OData Service. For this we have to create a return model and repository:\n\n```csharp\npublic class MediaItemDataModel : EntityIdentity\n{\n}\n \npublic class MediaItemRepository : IReadOnlyEntityRepository\n{\n    public Task GetById(string id)\n    {\n        return Task.FromResult(new MediaItemDataModel());\n    }\n \n    public Task<IQueryable<MediaItemDataModel>> GetData()\n    {\n        var list = new List<MediaItemDataModel>();\n        return Task.FromResult<IQueryable<MediaItemDataModel>>(list.AsQueryable());\n    }\n}\n```\n\nThis MediaItemDataModel inherits the EntityIdentity as used in the default Item Service. We don’t need anything else, because all we need to know in XC is the Sitecore Item ID. It is a bit weird that we have to create a IReadOnlyEntityRepository as we don’t actually do anything with it, but this is only because the OData controller we are creating needs a IReadOnlyEntityRepository.\n\n```csharp\n[AnonymousUserFilter (AllowAnonymous = AllowAnonymousOptions.Disallow)]\npublic class MediaItemController : ServiceBaseODataController<MediaItemDataModel> {\n    private readonly IReadOnlyEntityRepository<MediaItemDataModel> _repository;\n \n    public MediaItemController () : base (ServiceLocator.ServiceProvider.GetRequiredService<IReadOnlyEntityRepository<MediaItemDataModel>> ()) {\n        _repository = ServiceLocator.ServiceProvider.GetRequiredService<IReadOnlyEntityRepository<MediaItemDataModel>> ();\n    }\n \n    public IHttpActionResult Get ([FromODataUri] string imageUrl, [FromODataUri] string sitecorePath) {\n        if (string.IsNullOrEmpty (imageUrl))\n            return BadRequest (\"Specify the imageUrl property.\");\n        if (string.IsNullOrEmpty (sitecorePath))\n            return BadRequest (\"Specify the sitecorePath property.\");\n \n        if (!sitecorePath.StartsWith (\"/sitecore/media library/\"))\n            sitecorePath = sitecorePath.StartsWith (\"/\") ? $\"/sitecore/media library{sitecorePath}\" : $\"/sitecore/media library/{sitecorePath}\";\n \n        var fileNameInclExtension = imageUrl.Substring (imageUrl.LastIndexOf (\"/\", StringComparison.InvariantCultureIgnoreCase) + 1,\n            (imageUrl.Length - imageUrl.LastIndexOf (\"/\", StringComparison.InvariantCultureIgnoreCase)) - 1).Split ('?').FirstOrDefault ();\n \n        if (string.IsNullOrEmpty (fileNameInclExtension))\n            return BadRequest (\"No fileName could be extracted from the imageUrl.\");\n \n        var fileName = fileNameInclExtension.Split ('.').FirstOrDefault () ?? fileNameInclExtension;\n \n        var newItem = CreateMediaItem (imageUrl, sitecorePath, fileName, fileNameInclExtension);\n        PublishItem (newItem);\n \n        return Ok (new MediaItemDataModel () {\n            Id = newItem.ID.ToString ()\n        });\n    }\n \n    private Item CreateMediaItem (string imageUrl, string sitecorePath, string mediaItemName, string fullMediaItemName) {\n        var destination = sitecorePath.EndsWith (\"/\") ?\n            $\"{sitecorePath}{mediaItemName}\" :\n            $\"{sitecorePath}/{mediaItemName}\";\n \n        var options = new Sitecore.Resources.Media.MediaCreatorOptions () {\n            FileBased = false,\n            IncludeExtensionInItemName = false,\n            OverwriteExisting = true,\n            Versioned = false,\n            Destination = destination,\n            Database = Sitecore.Configuration.Factory.GetDatabase (\"master\")\n        };\n \n        using (var wc = new System.Net.WebClient ()) {\n            var daa = wc.DownloadData (imageUrl);\n            using (var memoryStream = new MemoryStream (daa)) {\n                using (new SecurityDisabler ()) {\n                    var mediaItem = Sitecore.Resources.Media.MediaManager.Creator.CreateFromStream (memoryStream, fullMediaItemName, options);\n                    memoryStream.Dispose ();\n                    return mediaItem;\n                }\n            }\n        }\n    }\n \n    private void PublishItem (Item item) {\n        try {\n            PublishOptions po = new PublishOptions (Sitecore.Configuration.Factory.GetDatabase (\"master\"), Sitecore.Configuration.Factory.GetDatabase (\"web\"), PublishMode.SingleItem, Sitecore.Context.Language, DateTime.Now);\n            po.RootItem = item;\n            po.Deep = true; // Publishing subitems\n \n            (new Publisher (po)).Publish ();\n        } catch (Exception ex) {\n            Sitecore.Diagnostics.Log.Error (\"Exception publishing items from custom pipeline! : \" + ex, this);\n        }\n    }\n}\n```\n\nIn this example implementation, we get a URL to the image we want to upload and a Sitecore Path which will be the parent of the new Sitecore Item. Using these two variables we download the image, create a Media Item for it and eventually publish the new Item.\n\nNote the attribute we use on this Controller. If you don’t specifically set any authentication/authorization on these services they will default to be available to anybody, and that’s something we don’t want of course. The manager we will use on Sitecore XC side already sends authorization properties out-of-the-box, so we don’t actually have to do anything for that matter.\n\nNext we need to register the repository:\n\n```csharp\npublic class CustomServiceConfigurator : IServicesConfigurator\n{\n    public void Configure(IServiceCollection serviceCollection)\n    {\n        var assemblies = new[] { GetType().Assembly };\n \n        serviceCollection.AddWebApiControllers(assemblies);\n        serviceCollection.AddSingleton<IReadOnlyEntityRepository<MediaItemDataModel>, MediaItemRepository>();\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration xmlns:patch=\"http://www.sitecore.net/xmlconfig/\">\n    <sitecore>\n        <services>\n            <configurator type=\"Sitecore.Foundation.CustomSitecoreServices.DependencyInjection.CustomServiceConfigurator, Sitecore.Foundation.CustomSitecoreServices\"/>\n        </services>\n    </sitecore>\n</configuration>\n```\n\nAnd last but not least we have to actually register the OData Service:\n\n```csharp\npublic class MediaItemServiceDescriptor : AggregateDescriptor\n{\n    public MediaItemServiceDescriptor()\n        : base(\n            \"media\", //route name\n            \"media\",  //route prefix\n            new DefaultEdmModelBuilder(new []\n            {\n                new EntitySetDefinition(typeof(MediaItemDataModel), \"MediaItem\")\n            }))\n    {\n    }\n}\n```\n\n## Sitecore XC implementation\n\nNow that we have done all of that we are done on the Sitecore XP part and we can start using it in our XC implementation.\n\nSitecore XC has a SitecoreConnectionManager which they use to get Item data from Sitecore XP. We can use this same manager to call our custom OData Service.\\\nAll we have to provide the manager with is a CommerceContext, OData service URL, a method and a ItemModel. This ItemModel input is something Sitecore uses specifically for calling the Item Service. Instead of using that, we can also add our properties to the action input.\\\nEventually the implementation will look something like this:\n\n```csharp\n/// <summary>\n/// Use the OData Sitecore Service to upload the asset to the Sitecore Media Library and return the Item ID.\n/// </summary>\n/// <param name=\"context\">The Commerce Context.</param>\n/// <param name=\"url\">The asset url.</param>\n/// <param name=\"sitecorePath\">The Sitecore path in which the asset should be uploaded.</param>\n/// <returns>The uploaded Item ID.</returns>\nprivate async Task<string> UploadAsset(CommerceContext context, string url, string sitecorePath)\n{\n    try\n    {\n        var action = $\"sitecore/api/ssc/aggregate/media/MediaItem?imageUrl={HttpUtility.UrlEncode(url)}&amp;sitecorePath={sitecorePath}\";\n        var httpResponseMessage = await _sitecoreConnectionManager.ProcessRequestAsync(context, action, \"GET\", null);\n        if (httpResponseMessage == null || !httpResponseMessage.IsSuccessStatusCode)\n            return \"\";\n \n        return JsonConvert.DeserializeObject<MediaItemModel>(await httpResponseMessage.Content.ReadAsStringAsync())?.Id ?? \"\";\n    }\n    catch (Exception ex)\n    {\n        context.LogException(nameof(SynchronizeSellableItemDigitalAssetsBlock), ex);\n        return \"\";\n    }\n}\n```\n\nAnd with that, you are done! We now have all the building blocks to automatically import Media Items from inside a Sitecore Commerce process instead of somehow uploading them separately."
}