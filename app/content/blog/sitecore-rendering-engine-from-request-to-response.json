{
  "publishedAt": "04-11-2021",
  "title": "Sitecore Rendering Engine - From Request to Response",
  "content": "Continuing on my previous blog posts, in this post I want to continue down the request handling flow to see how the Layout Service request is triggered and how that results in a page being rendered.\n\n## Making the request\n\nAs mentioned in earlier posts, the \\[UseSitecoreRendering] attribute in the fallback controller (out-of-the-box this is set on the Index method from the DefaultController) starts another Middleware component, the RenderingEngineMiddleware. This middleware is triggered for every request which gets processed by this fallback controller.\\\nThis RenderingEngineMiddleware is important, because this is the part of the code which actually triggers the call to the Layout Service. In below code snippet you can see this Middleware component, once invoked, will use the ISitecoreLayoutClient service (which is registered in the Startup.cs).\n\n```csharp\npublic async Task Invoke(\n  HttpContext httpContext,\n  IViewComponentHelper viewComponentHelper,\n  IHtmlHelper htmlHelper)\n{\n  Assert.ArgumentNotNull<HttpContext>(httpContext, nameof (httpContext));\n  if (httpContext.Items.ContainsKey((object) nameof (RenderingEngineMiddleware)))\n    throw new ApplicationException(Sitecore.AspNet.RenderingEngine.Resources.Exception_InvalidRenderingEngineConfiguration);\n  if (httpContext.GetSitecoreRenderingContext() == null)\n  {\n    SitecoreLayoutResponse sitecoreLayoutResponse = await this.GetSitecoreLayoutResponse(httpContext).ConfigureAwait(false);\n    httpContext.SetSitecoreRenderingContext((ISitecoreRenderingContext) new SitecoreRenderingContext()\n    {\n      Response = sitecoreLayoutResponse,\n      RenderingHelpers = new RenderingHelpers(viewComponentHelper, htmlHelper)\n    });\n  }\n  else\n    httpContext.GetSitecoreRenderingContext().RenderingHelpers = new RenderingHelpers(viewComponentHelper, htmlHelper);\n  foreach (Action<HttpContext> postRenderingAction in (IEnumerable<Action<HttpContext>>) this._options.PostRenderingActions)\n    postRenderingAction(httpContext);\n  httpContext.Items.Add((object) nameof (RenderingEngineMiddleware), (object) null);\n  await this._next(httpContext).ConfigureAwait(false);\n}\n\nprivate async Task<SitecoreLayoutResponse> GetSitecoreLayoutResponse(\n  HttpContext httpContext)\n{\n  SitecoreLayoutRequest request = this._requestMapper.Map(httpContext.Request);\n  Assert.NotNull<SitecoreLayoutRequest>(request);\n  return await this._layoutService.Request(request).ConfigureAwait(false);\n}\n```\n\nThis ISitecoreLayoutService will in turn trigger a request to the Layout Service and return it's response as a SitecoreLayoutResponse object. As you can see, this response object is then stored in the HttpContext. As the HttpContext is something that lives throughout the entire request lifetime, this means from this moment forth it will be possible to retrieve the raw Layout Service response from the HttpContext. And that is exactly the way Sitecore also uses this response, because as you can see this Middleware component doesn't do anything other than just requesting and storing that Layout Service object.\n\n## Binding the models\n\nThe next step in order to render a page, is populate the Route object parameter from the Index method in the fallback controller. This is done by using Model Binding (my previous post describes what this is).\\\nSitecore has chosen to use model binding for pretty much all of the context related models. I am not going to describe the entire process of how these models are registered for usage in model binding, that would be too much information, but I want to highlight two steps/classes in this flow. If we take the Route object for example, then we can find a SitecoreLayoutRouteBindingSource class which is responsible for populating the Route object with details from the ISitecoreRenderingContext object.\n\n```csharp\npublic override object? GetModel(\n  IServiceProvider serviceProvider,\n  ModelBindingContext bindingContext,\n  ISitecoreRenderingContext context)\n{\n  Assert.ArgumentNotNull<IServiceProvider>(serviceProvider, nameof (serviceProvider));\n  Assert.ArgumentNotNull<ModelBindingContext>(bindingContext, nameof (bindingContext));\n  Assert.ArgumentNotNull<ISitecoreRenderingContext>(context, nameof (context));\n  Type modelType = bindingContext.get_ModelMetadata().get_ModelType();\n  Route route = context.Response?.Content?.Sitecore?.Route;\n  return route != null && modelType == typeof (Route) ? (object) route : (object) null;\n}\n```\n\nWhere does this context object come from? This GetModel method is invoked by the SitecoreLayoutModelBinder<T>, where T in this case if Route of course. This class will retrieve the ISitecoreRenderingContext from the HttpContext and passes it to the SitecoreLayoutRouteBindingSource to have it create the Route object.\n\n```csharp\npublic Task BindModelAsync(ModelBindingContext bindingContext)\n{\n  Assert.ArgumentNotNull<ModelBindingContext>(bindingContext, nameof (bindingContext));\n  T obj1 = bindingContext.get_BindingSource() as T;\n  if (BindingSource.op_Equality((BindingSource) (object) obj1, (BindingSource) null))\n    obj1 = Activator.CreateInstance<T>();\n  ISitecoreRenderingContext renderingContext = bindingContext.get_HttpContext().GetSitecoreRenderingContext();\n  using (IServiceScope scope = ServiceProviderServiceExtensions.CreateScope(this._serviceProvider))\n  {\n    object model = obj1.GetModel(scope.ServiceProvider, bindingContext, renderingContext);\n    if (model != null)\n    {\n      ValidationStateDictionary validationState = bindingContext.get_ValidationState();\n      object obj2 = model;\n      ValidationStateEntry validationStateEntry = new ValidationStateEntry();\n      validationStateEntry.set_SuppressValidation(true);\n      validationState.Add(obj2, validationStateEntry);\n      bindingContext.set_Result(ModelBindingResult.Success(model));\n    }\n    else\n    {\n      ...\n    }\n  }\n  return Task.CompletedTask;\n}\n```\n\nThis approach is used for many such objects, like the Response, Component, Context and, as we have seen, the Route object.\n\n## Almost there\n\nWe now finally have a pretty complete picture of how a request to the ASP.NET Core application results in Middleware components being triggered, the Sitecore Layout Service being called and used for Model Binding to finally have a fairly straight forward MVC Controller triggered and it's parameters populated.\\\nFrom here, the path to generating the result page is more simple. The populated Route object contains all the details necessary to render a page, it includes the different placeholders on the page, components and their content. If you take a quick peek at the View for this Index method, you will see this will use tag helpers to render different Sitecore placeholder components which, based on the name property given, will render parts of the Layout Service response.\n\nI hope these posts have helped you get a better understanding of how the ASP.NET Core Rendering Host works and figure out how you can fully customize it for your needs.",
  "seoDescription": "In this post we figure out how the Sitecore Rendering Engine triggers a request to the Sitecore Layout Service and is able to render a page based on it."
}